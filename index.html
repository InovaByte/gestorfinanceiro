<html><head><base href="https://www.binance.com/"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia</title><style>
body {
  font-size: 16px;
  padding: 1rem;
  font-family: Arial, sans-serif;
  background-color: #f0f2f5;
  margin: 0;
  color: #333;
}
.container {
  max-width: 100%;
  margin: 0 auto;
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
h1 {
  color: #f0b90b;
  text-align: center;
  font-size: 1.5rem;
}
.controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
}
button {
  background-color: #f0b90b;
  border: none;
  color: white;
  padding: 0.5rem 1rem;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 1rem;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
}
.stats {
  display: flex;
  justify-content: space-between;
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 20px;
}
.stat {
  text-align: center;
}
.stat-value {
  font-size: 1.2rem;
  font-weight: bold;
  color: #f0b90b;
}
#log {
  margin-top: 20px;
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  font-family: monospace;
}
#signals {
  margin-top: 20px;
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 4px;
  max-height: 200px;
  overflow-y: auto;
}
.signal {
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 4px;
}
.signal.buy {
  background-color: #d4edda;
  color: #155724;
}
.signal.sell {
  background-color: #f8d7da;
  color: #721c24;
}
#tradingview-widget-container {
  position: relative;
  height: 60vh !important;
  margin-bottom: 20px;
}
#tradingview-widget-container > div {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
#symbolSelector {
  width: 100%;
  padding: 10px;
  margin-bottom: 20px;
  font-size: 16px;
}
@media (max-width: 767px) {
  body {
    font-size: 14px;
  }
  .container {
    padding: 0.5rem;
  }
  h1 {
    font-size: 1.2rem;
  }
  .controls {
    flex-direction: column;
  }
  button {
    width: 100%;
    margin-bottom: 0.5rem;
  }
  .stats {
    flex-direction: column;
  }
  .stat {
    margin-bottom: 0.5rem;
  }
  #tradingview-widget-container {
    height: 300px !important;
  }
}
@media (min-width: 768px) {
  .container {
    max-width: 1200px;
    padding: 2rem;
  }
  
  h1 {
    font-size: 2rem;
  }
  
  .controls {
    flex-direction: row;
  }
  
  button {
    width: auto;
  }
  
  .stats {
    flex-direction: row;
  }
  
  .stat {
    margin-bottom: 0;
  }
  
  #tradingview-widget-container {
    height: 400px !important;
  }
}
@media (min-width: 1024px) {
  .container {
    padding: 2.5rem;
  }
  
  h1 {
    font-size: 2.5rem;
  }
  
  #tradingview-widget-container {
    height: 500px !important;
  }
}
body.dark-mode {
  background-color: #1a1a1a;
  color: #ffffff;
}
body.dark-mode .container {
  background-color: #2a2a2a;
}
body.dark-mode button {
  background-color: #3a3a3a;
  color: #ffffff;
}
body.dark-mode .stats {
  background-color: #3a3a3a;
}
body.dark-mode .stat-value {
  color: #f0b90b;
}
body.dark-mode #log,
body.dark-mode #signals {
  border-color: #4a4a4a;
}
body.dark-mode .signal.buy {
  background-color: #1e3a2b;
  color: #4caf50;
}
body.dark-mode .signal.sell {
  background-color: #3a1e1e;
  color: #f44336;
}
footer {
  margin-top: 20px;
  padding: 10px;
  background-color: #f0f2f5;
  text-align: center;
  font-size: 0.9rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
body.dark-mode footer {
  background-color: #2a2a2a;
  color: #ffffff;
}
.language-toggle {
  background-color: transparent;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background-color 0.3s;
}
.language-toggle:hover {
  background-color: #e0e0e0;
}
body.dark-mode .language-toggle {
  border-color: #555;
  color: #ffffff;
}
body.dark-mode .language-toggle:hover {
  background-color: #3a3a3a;
}
#networkStatus {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 12px;
}
</style></head><body>
  <div class="container">
    <h1>Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia</h1>
    <select id="symbolSelector"></select>
    <div class="controls">
      <button id="startBtn">Iniciar Bot</button>
      <button id="stopBtn">Parar Bot</button>
      <button id="themeToggleBtn">Alternar Modo Escuro</button>
    </div>
    <div id="tradingview-widget-container"></div>
    <div class="stats">
      <div class="stat">
        <div>Sinais Gerados</div>
        <div id="signalsCount" class="stat-value">0</div>
      </div>
      <div class="stat">
        <div>√öltimo Pre√ßo</div>
        <div id="lastPrice" class="stat-value">0 USDT</div>
      </div>
      <div class="stat">
        <div>Posi√ß√µes Abertas</div>
        <div id="openPositions" class="stat-value">0</div>
      </div>
    </div>
    <div id="signals"></div>
    <div id="log"></div>
  </div>
  <footer>
    <p>&copy; 2023 Jean Vieira. Todos os direitos reservados.</p>
    <button id="languageToggle" class="language-toggle">üåê PT</button>
  </footer>
  <div id="networkStatus"></div>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>
<script>
window.addEventListener('unhandledrejection', function(event) {
  console.error('Unhandled rejection (promise: ', event.promise, ', reason: ', event.reason, ').');
  logMessage(`Erro n√£o tratado: ${event.reason}`);
});
function createNetworkStatusIndicator() {
  const indicator = document.createElement('div');
  indicator.id = 'networkStatus';
  indicator.style.position = 'fixed';
  indicator.style.top = '10px';
  indicator.style.right = '10px';
  indicator.style.padding = '5px 10px';
  indicator.style.borderRadius = '5px';
  indicator.style.fontSize = '12px';
  document.body.appendChild(indicator);
  return indicator;
}
const networkStatus = createNetworkStatusIndicator();
let symbol = 'BTCUSDT';
const interval = '15m';
let leverage = 20;
let positions = [];
let lastSignalTime = 0;
const signalCooldown = 15 * 60 * 1000; // 15 minutes in milliseconds
let isRunning = false;
let ws;
let signalsCount = 0;
let prices = [];
let volumes = [];
let ema50 = [];
let ema200 = [];
let rsiValues = [];
let widget;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
const baseReconnectDelay = 1000;
// Initialize Firebase
const firebaseConfig = {
  apiKey: "",
  authDomain: "bot-trading-99f76.firebaseapp.com",
  projectId: "bot-trading-99f76",
  storageBucket: "bot-trading-99f76.appspot.com",
  messagingSenderId: "820777140022",
  appId: "1:820777140022:web:85d5e9114bb8e4d4c93d97",
  measurementId: "G-XS0JKX9TR7"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
async function fetchBinanceSymbols() {
  try {
    networkStatus.textContent = 'Conectando...';
    networkStatus.style.backgroundColor = 'yellow';
    const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    networkStatus.textContent = 'Conectado';
    networkStatus.style.backgroundColor = 'green';
    return data.symbols
      .filter(symbol => symbol.status === 'TRADING')
      .map(symbol => symbol.symbol);
  } catch (error) {
    console.error('Erro ao buscar s√≠mbolos da Binance:', error);
    logMessage(`Erro ao buscar s√≠mbolos da Binance: ${error.message}`);
    networkStatus.textContent = 'Desconectado';
    networkStatus.style.backgroundColor = 'red';
    return [];
  }
}
async function fetchHistoricalData(symbol, interval, period) {
  try {
    const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=1000`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    const prices = data.map(candle => parseFloat(candle[4])); // Close price
    const volumes = data.map(candle => parseFloat(candle[5])); // Volume
    
    return { prices, volumes };
  } catch (error) {
    console.error('Error fetching historical data:', error);
    logMessage(`Error fetching historical data: ${error.message}`);
    throw error;
  }
}
function populateSymbolSelector(symbols) {
  const selector = document.getElementById('symbolSelector');
  symbols.forEach(symbol => {
    const option = document.createElement('option');
    option.value = symbol;
    option.textContent = symbol;
    selector.appendChild(option);
  });
}
function initTradingViewWidget(symbol, isDarkMode, lang = 'pt') {
  if (widget) {
    widget.remove();
  }
  widget = new TradingView.widget({
    "width": "100%",
    "height": "100%",
    "symbol": "BINANCE:" + symbol,
    "interval": "15",
    "timezone": "Etc/UTC",
    "theme": isDarkMode ? "dark" : "light",
    "style": "1",
    "locale": lang,
    "toolbar_bg": isDarkMode ? "#2a2a2a" : "#f1f3f6",
    "enable_publishing": false,
    "hide_side_toolbar": false,
    "allow_symbol_change": true,
    "studies": [
      "MASimple@tv-basicstudies",
      "MASimple@tv-basicstudies",
      "RSI@tv-basicstudies",
      "MACD@tv-basicstudies",
      "BB@tv-basicstudies"
    ],
    "container_id": "tradingview-widget-container",
    "studies_overrides": {
      "moving average.length": 9,
      "moving average.1.length": 21,
      "relative strength index.length": 14,
      "moving average convergence/divergence.fast length": 12,
      "moving average convergence/divergence.slow length": 26,
      "moving average convergence/divergence.signal smoothing": 9,
      "bollinger bands.length": 20,
      "bollinger bands.stddev": 2
    }
  });
}
function updateSymbol(newSymbol) {
  symbol = newSymbol;
  logMessage(`S√≠mbolo atualizado para ${symbol}`);
  if (isRunning) {
    isRunning = false;
    if (ws) ws.close();
    setTimeout(() => {
      isRunning = true;
      runBot();
    }, 1000);
  }
  const isDarkMode = document.body.classList.contains('dark-mode');
  initTradingViewWidget(symbol, isDarkMode, currentLanguage);
}
function saveDataToFirebase() {
  db.collection("tradingData").doc("currentState").set({
    prices: prices,
    volumes: volumes,
    ema50: ema50,
    ema200: ema200,
    rsiValues: rsiValues,
    positions: positions,
    signalsCount: signalsCount,
    lastSignalTime: lastSignalTime
  })
  .then(() => console.log("Dados salvos no Firebase"))
  .catch((error) => console.error("Erro ao salvar dados: ", error));
}
function loadDataFromFirebase() {
  db.collection("tradingData").doc("currentState").get()
    .then((doc) => {
      if (doc.exists) {
        const data = doc.data();
        prices = data.prices;
        volumes = data.volumes;
        ema50 = data.ema50;
        ema200 = data.ema200;
        rsiValues = data.rsiValues;
        positions = data.positions;
        signalsCount = data.signalsCount;
        lastSignalTime = data.lastSignalTime;
        
        // Update UI with loaded data
        document.getElementById('signalsCount').textContent = signalsCount;
        document.getElementById('lastPrice').textContent = `${prices[prices.length - 1]} USDT`;
        document.getElementById('openPositions').textContent = positions.length;
        
        console.log("Dados carregados do Firebase");
      } else {
        console.log("Nenhum dado encontrado no Firebase");
      }
    })
    .catch((error) => console.error("Erro ao carregar dados: ", error));
}
document.addEventListener('DOMContentLoaded', loadDataFromFirebase);
function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  let ema = data[0];
  return data.map((price, i) => {
    if (i === 0) return ema;
    return (price * k) + (ema * (1 - k));
  });
}
function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1) {
    return Array(prices.length).fill(0);
  }

  let gains = [];
  let losses = [];
  for (let i = 1; i < prices.length; i++) {
    const difference = prices[i] - prices[i - 1];
    if (difference >= 0) {
      gains.push(difference);
      losses.push(0);
    } else {
      gains.push(0);
      losses.push(Math.abs(difference));
    }
  }

  let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;

  let rsi = [];
  for (let i = 0; i < period; i++) {
    rsi.push(0);
  }

  for (let i = period; i < prices.length; i++) {
    const rs = avgGain / avgLoss;
    const currentRSI = 100 - (100 / (1 + rs));
    rsi.push(currentRSI);

    avgGain = (avgGain * (period - 1) + gains[i]) / period;
    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
  }

  return rsi;
}
function calculateSMA(data, period) {
  if (data.length < period) {
    return [];
  }

  const sma = [];
  for (let i = 0; i < data.length - period + 1; i++) {
    const sum = data.slice(i, i + period).reduce((a, b) => a + b, 0);
    sma.push(sum / period);
  }

  return sma;
}
function calculateBollingerBands(prices, period = 20, multiplier = 2) {
  const sma = calculateSMA(prices.slice(-period));
  const stdDev = Math.sqrt(
    prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma[0], 2), 0) / period
  );
  
  const upper = sma[0] + (multiplier * stdDev);
  const lower = sma[0] - (multiplier * stdDev);
  
  return {
    upper: [upper],
    middle: sma,
    lower: [lower]
  };
}
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const fastEMA = calculateEMA(prices, fastPeriod);
  const slowEMA = calculateEMA(prices, slowPeriod);
  
  const macdLine = fastEMA.map((fast, i) => fast - slowEMA[i]);
  
  const signalLine = calculateEMA(macdLine, signalPeriod);
  
  return { macdLine, signalLine };
}
function logMessage(message) {
  console.log(message);
  const logElement = document.getElementById('log');
  const logEntry = document.createElement('div');
  logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
  logElement.appendChild(logEntry);
  logElement.scrollTop = logElement.scrollHeight;
}
function displaySignal(signal, price) {
  signalsCount++;
  document.getElementById('signalsCount').textContent = signalsCount;
  const signalsContainer = document.getElementById('signals');
  const signalElement = document.createElement('div');
  signalElement.className = `signal ${signal}`;
  
  const lastRSI = rsiValues[rsiValues.length - 1].toFixed(2);
  const lastSMA50 = calculateSMA(prices, 50)[prices.length - 1].toFixed(2);
  const lastSMA200 = calculateSMA(prices, 200)[prices.length - 1].toFixed(2);
  const { macdLine, signalLine } = calculateMACD(prices);
  const lastMACD = macdLine[macdLine.length - 1].toFixed(2);
  const lastSignalLine = signalLine[signalLine.length - 1].toFixed(2);

  signalElement.innerHTML = `
    <strong>Sinal de ${signal.toUpperCase()} a ${price} USDT</strong><br>
    RSI: ${lastRSI}<br>
    SMA50: ${lastSMA50}<br>
    SMA200: ${lastSMA200}<br>
    MACD: ${lastMACD}<br>
    Linha de Sinal: ${lastSignalLine}
  `;
  
  signalsContainer.insertBefore(signalElement, signalsContainer.firstChild);
  if (signalsContainer.children.length > 10) {
    signalsContainer.removeChild(signalsContainer.lastChild);
  }
  
  saveDataToFirebase();
}
function generateSignal() {
  if (prices.length < 200) {
    return null;
  }
  const lastPrice = prices[prices.length - 1];
  const sma50 = calculateSMA(prices, 50);
  const sma200 = calculateSMA(prices, 200);
  const rsi = calculateRSI(prices, 14);
  const { macdLine, signalLine } = calculateMACD(prices);
  const bollingerBands = calculateBollingerBands(prices);
  const lastSMA50 = sma50[sma50.length - 1];
  const lastSMA200 = sma200[sma200.length - 1];
  const lastRSI = rsi[rsi.length - 1];
  const lastMACD = macdLine[macdLine.length - 1];
  const lastSignal = signalLine[signalLine.length - 1];
  const lastUpperBB = bollingerBands.upper[bollingerBands.upper.length - 1];
  const lastLowerBB = bollingerBands.lower[bollingerBands.lower.length - 1];
  const lastMiddleBB = bollingerBands.middle[bollingerBands.middle.length - 1];

  const currentTime = Date.now();
  if (currentTime - lastSignalTime < signalCooldown) {
    return null;
  }

  const isBuySignal = 
    lastSMA50 > lastSMA200 &&
    lastRSI > 40 && lastRSI < 60 &&
    lastMACD > lastSignal &&
    lastPrice > lastMiddleBB &&
    prices.slice(-5).every(price => price > lastSMA50);

  const isSellSignal = 
    lastSMA50 < lastSMA200 &&
    lastRSI > 60 &&
    lastMACD < lastSignal &&
    lastPrice < lastMiddleBB &&
    prices.slice(-5).every(price => price < lastSMA50);

  if (isBuySignal) {
    lastSignalTime = currentTime;
    return 'buy';
  } else if (isSellSignal) {
    lastSignalTime = currentTime;
    return 'sell';
  }

  return null;
}
function openPosition(type, entryPrice) {
  const currentTime = Date.now();
  if (currentTime - lastSignalTime < signalCooldown) {
    logMessage(`Sinal ignorado devido ao per√≠odo de espera`);
    return;
  }

  const conflictingPosition = positions.find(p => p.type !== type);
  if (conflictingPosition) {
    logMessage(`N√£o √© poss√≠vel abrir posi√ß√£o ${type}. Posi√ß√£o conflitante ${conflictingPosition.type} existe.`);
    return;
  }

  const riskPercentage = 0.02;
  const accountBalance = 10000;
  const riskAmount = accountBalance * riskPercentage;
  const stopLossPercentage = 0.02;
  const takeProfitRatio = 2;

  const stopLossPrice = type === 'buy' 
    ? entryPrice * (1 - stopLossPercentage) 
    : entryPrice * (1 + stopLossPercentage);
  
  const takeProfitPrice = type === 'buy'
    ? entryPrice * (1 + (stopLossPercentage * takeProfitRatio))
    : entryPrice * (1 - (stopLossPercentage * takeProfitRatio));

  const position = {
    type,
    entryPrice,
    stopLossPrice,
    takeProfitPrice,
    trailingStopDistance: entryPrice * 0.015,
    quantity: riskAmount / Math.abs(entryPrice - stopLossPrice)
  };

  positions.push(position);
  logMessage(`Posi√ß√£o ${type} aberta: Entrada: ${entryPrice}, SL: ${stopLossPrice}, TP: ${takeProfitPrice}`);
  
  lastSignalTime = currentTime;
  saveDataToFirebase();
}
function updatePositions(currentPrice) {
  positions = positions.filter(position => {
    if (position.type === 'buy') {
      if (currentPrice >= position.takeProfitPrice) {
        logMessage(`Posi√ß√£o de compra fechada com lucro: Entrada: ${position.entryPrice}, Sa√≠da: ${currentPrice}`);
        return false;
      } else if (currentPrice <= position.stopLossPrice) {
        logMessage(`Posi√ß√£o de compra fechada com perda: Entrada: ${position.entryPrice}, Sa√≠da: ${currentPrice}`);
        return false;
      } else if (currentPrice - position.entryPrice > position.trailingStopDistance) {
        position.stopLossPrice = currentPrice - position.trailingStopDistance;
      }
    } else if (position.type === 'sell') {
      if (currentPrice <= position.takeProfitPrice) {
        logMessage(`Posi√ß√£o de venda fechada com lucro: Entrada: ${position.entryPrice}, Sa√≠da: ${currentPrice}`);
        return false;
      } else if (currentPrice >= position.stopLossPrice) {
        logMessage(`Posi√ß√£o de venda fechada com perda: Entrada: ${position.entryPrice}, Sa√≠da: ${currentPrice}`);
        return false;
      } else if (position.entryPrice - currentPrice > position.trailingStopDistance) {
        position.stopLossPrice = currentPrice + position.trailingStopDistance;
      }
    }
    return true;
  });

  saveDataToFirebase();
}
function normalWebSocketHandler(event) {
  const data = JSON.parse(event.data);
  if (data.k) {
    const candle = data.k;
    const closePrice = parseFloat(candle.c);
    prices.push(closePrice);
    volumes.push(parseFloat(candle.v));
    if (prices.length > 200) {
      prices.shift();
      volumes.shift();
    }
    ema50 = calculateEMA(prices, 50);
    ema200 = calculateEMA(prices, 200);
    rsiValues = calculateRSI(prices);
    document.getElementById('lastPrice').textContent = `${closePrice} USDT`;
    const signal = generateSignal();
    if (signal) {
      displaySignal(signal, closePrice);
      openPosition(signal, closePrice);
    }
    updatePositions(closePrice);
    document.getElementById('openPositions').textContent = positions.length;
    saveDataToFirebase();
  }
}
function connectWebSocket() {
  if (ws) {
    ws.close();
  }
  ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);
  ws.onopen = () => {
    logMessage('Conex√£o WebSocket aberta');
    reconnectAttempts = 0;
  };
  ws.onmessage = normalWebSocketHandler;
  ws.onclose = (event) => {
    logMessage(`Conex√£o WebSocket fechada. C√≥digo: ${event.code}, Motivo: ${event.reason}`);
    if (isRunning) {
      const delay = Math.min(30000, (reconnectAttempts + 1) * baseReconnectDelay);
      logMessage(`Tentando reconectar em ${delay / 1000} segundos...`);
      setTimeout(() => {
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          connectWebSocket();
        } else {
          logMessage('M√°ximo de tentativas de reconex√£o alcan√ßado. Por favor, reinicie o bot manualmente.');
          isRunning = false;
        }
      }, delay);
    }
  };
  ws.onerror = (error) => {
    logMessage(`Erro no WebSocket: ${error.message}`);
  };
}
async function runBot() {
  if (!isRunning) return;
  try {
    networkStatus.textContent = 'Conectando...';
    networkStatus.style.backgroundColor = 'yellow';
    const historicalData = await fetchHistoricalData(symbol, interval, '6 meses');
    
    prices = historicalData.prices;
    volumes = historicalData.volumes;

    ema50 = calculateEMA(prices, 50);
    ema200 = calculateEMA(prices, 200);
    rsiValues = calculateRSI(prices);

    reconnectAttempts = 0;
    connectWebSocket();
    networkStatus.textContent = 'Conectado';
    networkStatus.style.backgroundColor = 'green';
  } catch (error) {
    console.error('Erro ao executar o bot:', error);
    logMessage(`Erro ao executar o bot: ${error.message}`);
    if (error instanceof TypeError) {
      logMessage('Erro de rede. Verifique sua conex√£o com a internet.');
    }
    isRunning = false;
    networkStatus.textContent = 'Desconectado';
    networkStatus.style.backgroundColor = 'red';
    setTimeout(() => {
      if (isRunning) {
        logMessage('Tentando reconectar...');
        runBot();
      }
    }, 5000);
  }
}
document.addEventListener('DOMContentLoaded', async function() {
  try {
    const symbols = await fetchBinanceSymbols();
    populateSymbolSelector(symbols);
    document.getElementById('startBtn').addEventListener('click', () => {
      if (!isRunning) {
        isRunning = true;
        logMessage('Iniciando bot...');
        runBot();
      }
    });
    document.getElementById('stopBtn').addEventListener('click', () => {
      if (isRunning) {
        isRunning = false;
        if (ws) ws.close();
        logMessage('Parando bot...');
      }
    });
    document.getElementById('symbolSelector').addEventListener('change', (event) => {
      const newSymbol = event.target.value;
      updateSymbol(newSymbol);
    });
    document.getElementById('themeToggleBtn').addEventListener('click', toggleTheme);
    document.getElementById('languageToggle').addEventListener('click', toggleLanguage);
    
    const isDarkMode = localStorage.getItem('darkMode') === 'true';
    if (isDarkMode) {
      document.body.classList.add('dark-mode');
    }
    initTradingViewWidget(symbol, isDarkMode, currentLanguage);
  } catch (error) {
    console.error('Erro durante a inicializa√ß√£o:', error);
    logMessage(`Erro durante a inicializa√ß√£o: ${error.message}`);
  }
});
const translations = {
  'pt': {
    'title': 'Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia',
    'startBtn': 'Iniciar Bot',
    'stopBtn': 'Parar Bot',
    'themeToggleBtn': 'Alternar Modo Escuro',
    'signalsGenerated': 'Sinais Gerados',
    'lastPrice': '√öltimo Pre√ßo',
    'openPositions': 'Posi√ß√µes Abertas',
    'footer': '¬© 2023 Jean Vieira. Todos os direitos reservados.'
  },
  'en': {
    'title': 'Binance Futures Trading Bot - Trend Following Strategy',
    'startBtn': 'Start Bot',
    'stopBtn': 'Stop Bot',
    'themeToggleBtn': 'Toggle Dark Mode',
    'signalsGenerated': 'Signals Generated',
    'lastPrice': 'Last Price',
    'openPositions': 'Open Positions',
    'footer': '¬© 2023 Jean Vieira. All rights reserved.'
  },
  'es': {
    'title': 'Bot de Trading Binance Futures - Estrategia de Seguimiento de Tendencia',
    'startBtn': 'Iniciar Bot',
    'stopBtn': 'Detener Bot',
    'themeToggleBtn': 'Cambiar Modo Oscuro',
    'signalsGenerated': 'Se√±ales Generadas',
    'lastPrice': '√öltimo Precio',
    'openPositions': 'Posiciones Abiertas',
    'footer': '¬© 2023 Jean Vieira. Todos los derechos reservados.'
  }
};
let currentLanguage = 'pt';
function changeLanguage(lang) {
  currentLanguage = lang;
  document.querySelector('h1').textContent = translations[lang].title;
  document.getElementById('startBtn').textContent = translations[lang].startBtn;
  document.getElementById('stopBtn').textContent = translations[lang].stopBtn;
  document.getElementById('themeToggleBtn').textContent = translations[lang].themeToggleBtn;
  document.querySelector('.stat:nth-child(1) div:first-child').textContent = translations[lang].signalsGenerated;
  document.querySelector('.stat:nth-child(2) div:first-child').textContent = translations[lang].lastPrice;
  document.querySelector('.stat:nth-child(3) div:first-child').textContent = translations[lang].openPositions;
  document.querySelector('footer p').textContent = translations[lang].footer;
  
  const isDarkMode = document.body.classList.contains('dark-mode');
  reinitializeTradingViewWidget(isDarkMode, lang);
}
function reinitializeTradingViewWidget(isDarkMode, lang = 'pt') {
  initTradingViewWidget(symbol, isDarkMode, lang);
}
function toggleTheme() {
  const body = document.body;
  const isDarkMode = body.classList.toggle('dark-mode');
  localStorage.setItem('darkMode', isDarkMode);
  reinitializeTradingViewWidget(isDarkMode, currentLanguage);
}

function toggleLanguage() {
  const languages = ['pt', 'en', 'es'];
  const currentIndex = languages.indexOf(currentLanguage);
  const nextIndex = (currentIndex + 1) % languages.length;
  const nextLanguage = languages[nextIndex];
  changeLanguage(nextLanguage);
  document.getElementById('languageToggle').textContent = `üåê ${nextLanguage.toUpperCase()}`;
}
</script>
</body></html>
